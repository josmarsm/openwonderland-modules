/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath"
 * exception as provided by Sun in the License file that accompanied
 * this code.
 */

package org.jdesktop.wonderland.modules.marbleous.client.ui;

import com.jme.math.Quaternion;
import com.jme.math.Vector3f;
import java.awt.Component;
import java.text.DecimalFormat;
import javax.swing.AbstractCellEditor;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

/**
 * Frame for editing the properties of knots in a TrackSegment
 * @author Bernard Horan
 */
public class KnotFrame extends javax.swing.JFrame {
    //The preferred width of the columns
    private static final int[] COLUMN_WIDTHS = {10, 10, 10, 10, 10, 10};
    //Use a formatter to display doubles to 2 decimal places
    private static DecimalFormat twoDForm = new DecimalFormat("#.##");


    /** Creates new form KnotFrame */
    public KnotFrame() {
        initComponents();
        initTableModel();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        knotTable = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        knotTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        knotTable.setGridColor(java.awt.Color.black);
        knotTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane1.setViewportView(knotTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(19, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(19, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new KnotFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    protected javax.swing.JScrollPane jScrollPane1;
    protected javax.swing.JTable knotTable;
    // End of variables declaration//GEN-END:variables

    private void initTableModel() {
        KnotTableModel tableModel = new KnotTableModel();
        //TODO remove after testing
        tableModel.setDefaultValues();
        knotTable.setModel(tableModel);

        //Use a specialised renderer and editor for the position column
        TableColumn positionColumn = knotTable.getColumnModel().getColumn(1);
        positionColumn.setCellRenderer(new PositionCellRenderer());
        positionColumn.setCellEditor(new PositionCellEditor());

        //Use a specialised renderer and editor for the rotation column
        TableColumn quaternionColumn = knotTable.getColumnModel().getColumn(2);
        quaternionColumn.setCellRenderer(new QuaternionCellRenderer());
        quaternionColumn.setCellEditor(new QuaternionTableCellEditor());

        // For the remaining columns use an editor that constrains user input to
        // +/- 1
        for (int i = 3; i < 5; i++) {
            TableColumn column = knotTable.getColumnModel().getColumn(i);
            column.setCellEditor(new PlusMinusOneCellEditor());
        }

        //Set the preferred width of the columns
        for (int i = 0; i < 5; i++) {
            TableColumn column = knotTable.getColumnModel().getColumn(i);
            column.setPreferredWidth(COLUMN_WIDTHS[i]);            
        }
    }    

    //Renderer for rotation column
    public class QuaternionCellRenderer extends JLabel
                           implements TableCellRenderer {

        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            Quaternion quat = (Quaternion) value;
            float angleRadians = quat.toAngleAxis(new Vector3f(0,0,1));
            double angleDegrees = Math.toDegrees(angleRadians);

            setText(twoDForm.format(angleDegrees));
            if (isSelected) {
                setBackground(table.getSelectionBackground());
                setForeground(table.getSelectionForeground());
            } else {
                setBackground(table.getBackground());
                setForeground(table.getForeground());
            }
            setEnabled(table.isEnabled());
            setFont(table.getFont());
            return this;
        }
    }

    //Renderer for position column
    public class PositionCellRenderer extends JLabel
                           implements TableCellRenderer {

        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
            Vector3f position = (Vector3f) value;
            StringBuffer buffer = new StringBuffer();
            buffer.append(position.x);
            buffer.append(",");
            buffer.append(position.y);
            buffer.append(",");
            buffer.append(position.z);
            setText(buffer.toString());
            if (isSelected) {
                setBackground(table.getSelectionBackground());
                setForeground(table.getSelectionForeground());
            } else {
                setBackground(table.getBackground());
                setForeground(table.getForeground());
            }
            setEnabled(table.isEnabled());
            setFont(table.getFont());
            return this;
        }
    }
    
    //Editor for rotation column
    public class QuaternionTableCellEditor extends AbstractCellEditor implements TableCellEditor {
        // This is the textfield that will handle the editing of the cell value
        JTextField textfield = new JTextField();

        // This method is called when a cell value is edited by the user.
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int rowIndex, int vColIndex) {
            if (isSelected) {
                textfield.setBackground(table.getSelectionBackground());
                textfield.setForeground(table.getSelectionForeground());
            } else {
                textfield.setBackground(table.getBackground());
                textfield.setForeground(table.getForeground());
            }
            textfield.setEnabled(table.isEnabled());
            textfield.setFont(table.getFont());

            // Configure the textfield with the specified value
            Quaternion quat = (Quaternion) value;
            float angleRadians = quat.toAngleAxis(new Vector3f(0, 0, 1));
            float angleDegrees = (float) Math.toDegrees(angleRadians);
            textfield.setText(twoDForm.format(angleDegrees));

            // Return the configured textfield
            return textfield;
        }

        // This method is called when editing is completed.
        // It must return the new value to be stored in the cell.
        public Object getCellEditorValue() {
            float angleDegrees = Float.parseFloat(textfield.getText());
            float angleRadians = (float) Math.toRadians(angleDegrees);
            Quaternion quat = new Quaternion().fromAngleAxis(angleRadians, new Vector3f(0,0,1));
            return quat;
        }

        // This method is called just before the cell value
        // is saved. If the value is not valid, false should be returned.
        @Override
        public boolean stopCellEditing() {
            float angleDegrees = Float.parseFloat(textfield.getText());
            if (angleDegrees > 360) {
                return false;
            }
            if (angleDegrees < 0) {
                return false;
            }            
            return super.stopCellEditing();
        }
    }

    //Editor to constrain user input to be between -1 and +1
    public class PlusMinusOneCellEditor extends AbstractCellEditor implements TableCellEditor {
        // This is the textfield that will handle the editing of the cell value
        JTextField textfield = new JTextField();

        // This method is called when a cell value is edited by the user.
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int rowIndex, int vColIndex) {
            if (isSelected) {
                textfield.setBackground(table.getSelectionBackground());
                textfield.setForeground(table.getSelectionForeground());
            } else {
                textfield.setBackground(table.getBackground());
                textfield.setForeground(table.getForeground());
            }
            textfield.setEnabled(table.isEnabled());
            textfield.setFont(table.getFont());

            // Configure the textfield with the specified value
            textfield.setText(value.toString());

            // Return the configured textfield
            return textfield;
        }

        // This method is called when editing is completed.
        // It must return the new value to be stored in the cell.
        public Object getCellEditorValue() {
            return Float.parseFloat(textfield.getText());
        }

        // This method is called just before the cell value
        // is saved. If the value is not valid, false should be returned.
        @Override
        public boolean stopCellEditing() {
            float angleDegrees = Float.parseFloat(textfield.getText());
            if (angleDegrees > 1.0) {
                return false;
            }
            if (angleDegrees < -1.0) {
                return false;
            }
            return super.stopCellEditing();
        }

    }

    //This editor constrains user input so that the user can enter a 3 dimensional position
    public class PositionCellEditor extends AbstractCellEditor implements TableCellEditor {
        // This is the textfield that will handle the editing of the cell value
        JTextField textfield = new JTextField();

        // This method is called when a cell value is edited by the user.
        public Component getTableCellEditorComponent(JTable table, Object value,
                boolean isSelected, int rowIndex, int vColIndex) {
            // 'value' is value contained in the cell located at (rowIndex, vColIndex)

            if (isSelected) {
                textfield.setBackground(table.getSelectionBackground());
                textfield.setForeground(table.getSelectionForeground());
            } else {
                textfield.setBackground(table.getBackground());
                textfield.setForeground(table.getForeground());
            }
            textfield.setEnabled(table.isEnabled());
            textfield.setFont(table.getFont());

            Vector3f position = (Vector3f) value;
            StringBuffer buffer = new StringBuffer();
            buffer.append(position.x);
            buffer.append(",");
            buffer.append(position.y);
            buffer.append(",");
            buffer.append(position.z);
            textfield.setText(buffer.toString());

            // Return the configured textfield
            return textfield;
        }

        // This method is called when editing is completed.
        // It must return the new value to be stored in the cell.
        public Object getCellEditorValue() {
            return parse(textfield.getText());
        }

        // This method is called just before the cell value
        // is saved. If the value is not valid, false should be returned.
        public boolean stopCellEditing() {
            if (parse(textfield.getText()) == null) {
                return false;
            }
            return super.stopCellEditing();
        }

        private Vector3f parse(String aString) {
            String delims = "[,]";
            String[] tokens = aString.split(delims);
            if (tokens.length != 3) {
                System.err.println("Invalid number of dimensions");
                return null;
            }
            float x,y,z;
            try {
                x = Float.parseFloat(tokens[0]);
            } catch (NumberFormatException e) {
                System.err.println("Invalid x variable");
                return null;
            }
            try {
                y = Float.parseFloat(tokens[1]);
            } catch (NumberFormatException e) {
                System.err.println("Invalid y variable");
                return null;
            }
            try {
                z = Float.parseFloat(tokens[2]);
            } catch (NumberFormatException e) {
                System.err.println("Invalid x variable");
                return null;
            }
            Vector3f vector = new Vector3f(x, y, z);
            if (!Vector3f.isValidVector(vector)) {
                System.err.println("Invalid vector");
                return null;
            }
            return vector;
        }

    }

}
