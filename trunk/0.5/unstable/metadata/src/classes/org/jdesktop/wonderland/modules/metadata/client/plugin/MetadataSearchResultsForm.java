/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MetadataSearchResultsForm.java
 *
 * Created on Jul 8, 2009, 5:45:14 PM
 */

package org.jdesktop.wonderland.modules.metadata.client.plugin;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import org.jdesktop.wonderland.client.ClientContext;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.CellCache;
import org.jdesktop.wonderland.client.login.ServerSessionManager;
import org.jdesktop.wonderland.common.cell.CellID;
import org.jdesktop.wonderland.modules.metadata.client.MetadataTypesTable;

/**
 *
 * @author Matt
 */
public class MetadataSearchResultsForm extends javax.swing.JFrame implements TableModelListener{

  private static Logger logger = Logger.getLogger(MetadataSearchResultsForm.class.getName());

  // TODO could not add MetadataTypesTable to NetBeans GUI Builder
  // workaround: use customize code to make basicTabs instantiated as
  // a MTT. Cast basicTabs to an MTT and use the tabs reference instead.
  private MetadataTypesTable tabs;

  /**
   * stores metadata, with hits highlighted, for each cell result.
   * fetch the metadata and build a metadatatypestable on demand, cache the
   * result here.
   */
  private HashMap<CellID, MetadataTypesTable> metaTablesCache = new HashMap<CellID, MetadataTypesTable>();
  /**
   * the cellcache associated with the currently set results
   */
  private CellCache cellCache;

  // store all cell ID's not in cache - will have to get their info through
  // the metadataconnection
  ArrayList<CellID> outsideCache = new ArrayList<CellID>();

  /** Creates new form MetadataSearchResultsForm */
  public MetadataSearchResultsForm() {
      initComponents();

      // work-around for NetBeans GUI builder
      // see comment where tabs is declared
      tabs = (MetadataTypesTable) basicTabs;
      tabs.setTableCellsEditable(MetadataTypesTable.AllowEdits.NEVER);
      resultsTable.setModel(new ResultsTableModel());

      // add listeners
      resultsTable.getSelectionModel().addListSelectionListener(new resultsSelectionListener());
      resultsTable.getModel().addTableModelListener(this);
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jScrollPane1 = new javax.swing.JScrollPane();
    resultsTable = new javax.swing.JTable();
    jLabel1 = new javax.swing.JLabel();
    basicTabs = new MetadataTypesTable();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

    resultsTable.setModel(new javax.swing.table.DefaultTableModel(
      new Object [][] {
        {null, null},
        {null, null},
        {null, null},
        {null, null}
      },
      new String [] {
        "Cell Name", "Cell ID"
      }
    ) {
      Class[] types = new Class [] {
        java.lang.String.class, java.lang.String.class
      };
      boolean[] canEdit = new boolean [] {
        false, false
      };

      public Class getColumnClass(int columnIndex) {
        return types [columnIndex];
      }

      public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
      }
    });
    jScrollPane1.setViewportView(resultsTable);

    jLabel1.setText("Search Results");

    basicTabs.setPreferredSize(new java.awt.Dimension(32767, 32767));

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel1))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(basicTabs, javax.swing.GroupLayout.PREFERRED_SIZE, 400, javax.swing.GroupLayout.PREFERRED_SIZE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(basicTabs, javax.swing.GroupLayout.PREFERRED_SIZE, 313, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addGroup(layout.createSequentialGroup()
            .addComponent(jLabel1)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 22, Short.MAX_VALUE)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)))
        .addContainerGap())
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  /**
   * a search was completed, set the results to display, fetch metadata
   * @param results maps cellID's to list of mid hits for that cell
   * @param mgr the ServerSessionManager from which to get a cell cache
   */
  void setResults(HashMap<CellID, Set<Integer>> results, ServerSessionManager mgr) {
    // clear out old values
    tabs.clearTabs();
    metaTablesCache.clear();
    outsideCache.clear();
    
    // get cell cache.. doesn't matter what session from
    cellCache = ClientContext.getCellCache(mgr.getPrimarySession());


    for(Entry<CellID, Set<Integer>> e : results.entrySet()){
      CellID cid = e.getKey();
      logger.log(Level.INFO, "[Search Results] cid: " + cid + ", num hits:" + e.getValue().size());
      ResultsTableModel mod = (ResultsTableModel) resultsTable.getModel();
      // get cell and cell id, get name, add row
      String cellName = null;
      if(!fetchCellName(e.getKey(), cellName)){
        // need to send a message to server to get the cell name
        outsideCache.add(cid);
      }
      mod.addRow(e.getKey(), cellName);
    }
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JTabbedPane basicTabs;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JTable resultsTable;
  // End of variables declaration//GEN-END:variables

  private boolean fetchCellName(CellID cid, String cellName) {
    Cell c = cellCache.getCell(cid);
    if(c == null){
      // cell was out of range, but we know it exists
      // since it was returned by the metadata search
      // caller will have to get name on its own
      cellName = "not in cache - out of range";
      return false;
    }
    cellName = c.getName();
    return true;
  }
  // End of variables declaration

  class ResultsTableModel extends AbstractTableModel{
    ArrayList<CellID> cids = new ArrayList<CellID>();
    ArrayList<String> names = new ArrayList<String>();
    public int getRowCount() {
      return cids.size();
    }

    public int getColumnCount() {
      return 2;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {
      switch (columnIndex){
        case 0:
          if(rowIndex < cids.size()){
            return cids.get(rowIndex);
          }
          return null;
        case 1:
          if(rowIndex < names.size()){
            return names.get(rowIndex);
          }
          break;
      }
      return null;
    }

    void addRow(CellID cid, String name){
      logger.log(Level.INFO, "add row in search model");
//      logger.log(Level.INFO, "before adding, model size:" + cids.size());
      cids.add(cid);
      names.add(name);
      int row = cids.size() - 1;
      this.fireTableRowsInserted(cids.size() - 1,
                                 cids.size() - 1);
//      logger.log(Level.INFO, "after adding, model size:" + cids.size());
    }

    /**
     * disallow all edits
     * @param row
     * @param col
     * @return
     */
    @Override
    public boolean isCellEditable(int row, int col) {
      // never editable
      return false;
    }

  }

  public void tableChanged(TableModelEvent e) {
    logger.log(Level.INFO, "[SEARCH RESULTS] res table changed, repaint");
    repaint();
  }

  /**
   * build a cell's MetadataTypesTable, from the cache if possible, or by
   * querying the server if necessary
   *
   * then cache it
   * 
   * @param cid
   */
  private void buildMTTForCell(CellID cid) {
    MetadataTypesTable mtt = new MetadataTypesTable();
    mtt.setTableCellsEditable(MetadataTypesTable.AllowEdits.NEVER);
    if(!outsideCache.contains(cid)){
      logger.log(Level.INFO, "[SEARCH RESULTS] building MTT from cell cache");
      Cell c = cellCache.getCell(cid);
//      c.getComponent(MetadataComponent.class);
      
    }
    else{
      logger.log(Level.INFO, "[SEARCH RESULTS] outside cache, asking connection for info");
      // TODO add functionality to connection
      // for now, just leave it blank

    }

    metaTablesCache.put(cid, mtt);
  }

  /**
   * listens for selections of a row in the results panel
   * when a cell is selected, display its MetadataTypesTable
   */
  class resultsSelectionListener implements ListSelectionListener {
    public void valueChanged(ListSelectionEvent e) {
      boolean valid = false;
      int selectedIdx = resultsTable.getSelectedRow();
      if (!e.getValueIsAdjusting() && selectedIdx >= 0) {
          valid = true;
      }
      if(!valid){
        logger.info("[SEARCH RESULTS] invalid selection!");
        return;
      }
      CellID cid = (CellID) resultsTable.getValueAt(selectedIdx, 0);
      logger.info("[SEARCH RESULTS] selected new result: " + selectedIdx +
              " which is cid: " + cid);

      // if already in the cache, simply display that table
      if(metaTablesCache.containsKey(cid)){
        logger.info("[SEARCH RESULTS] MTT was in cache, displaying");
        tabs = metaTablesCache.get(cid);
        MetadataSearchResultsForm.this.repaint();
        return;
      }

      logger.info("[SEARCH RESULTS] was not in cache, fetch and display");
      buildMTTForCell(cid);
      
    }
   }
}
