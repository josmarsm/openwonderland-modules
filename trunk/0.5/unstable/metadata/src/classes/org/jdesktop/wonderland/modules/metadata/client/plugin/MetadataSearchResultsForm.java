/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MetadataSearchResultsForm.java
 *
 * Created on Jul 8, 2009, 5:45:14 PM
 */

package org.jdesktop.wonderland.modules.metadata.client.plugin;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Logger;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import org.jdesktop.wonderland.client.ClientContext;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.CellCache;
import org.jdesktop.wonderland.client.login.ServerSessionManager;
import org.jdesktop.wonderland.common.cell.CellID;
import org.jdesktop.wonderland.modules.metadata.client.MetadataComponent;
import org.jdesktop.wonderland.modules.metadata.client.MetadataTypesTable;
import org.jdesktop.wonderland.modules.metadata.common.MetadataSPI;
import org.jdesktop.wonderland.modules.metadata.common.messages.MetadataCellInfo;

/**
 *
 * @author Matt
 */
public class MetadataSearchResultsForm extends javax.swing.JFrame implements TableModelListener{

  private static Logger logger = Logger.getLogger(MetadataSearchResultsForm.class.getName());

  // TODO could not add MetadataTypesTable to NetBeans GUI Builder
  // workaround: use customize code to make basicTabs instantiated as
  // a MTT. Cast basicTabs to an MTT and use the tabs reference instead.
  private MetadataTypesTable tabs;

  /**
   * stores metadata, with hits highlighted, for each cell result.
   * fetch the metadata and build a metadatatypestable on demand, cache the
   * result here.
   */
  private HashMap<CellID, MetadataTypesTable> metaTablesCache = new HashMap<CellID, MetadataTypesTable>();

  /**
   * maps cells to the results of a search
   */
  private HashMap<CellID, MetadataCellInfo> searchResults = new HashMap<CellID, MetadataCellInfo>();

  // Note: querying cell cache will not let us get to the SERVER state, which
  // is where metadata is actually stored. For now, the metadata is sent over
  // in the response message and stored here.
  //
  // If in the future metadata is stored
  // on the server as well, then it could be accessed via the cell cache/request
  // cell outside of cache system, saving sending everything in a message.

  /** Creates new form MetadataSearchResultsForm */
  public MetadataSearchResultsForm() {
      initComponents();

      // work-around for NetBeans GUI builder
      // see comment where tabs is declared
      tabs = (MetadataTypesTable) basicTabs;
      tabs.setTableCellsEditable(MetadataTypesTable.AllowEdits.NEVER);
      resultsTable.setModel(new ResultsTableModel());

      // add listeners
      resultsTable.getSelectionModel().addListSelectionListener(new resultsSelectionListener());
      resultsTable.getModel().addTableModelListener(this);
  }

  @Override
  public void repaint(){
    super.repaint();
    logger.info("repainting main frame, tabs has " + tabs.getMetadataCount() + " pieces of metadata");
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jScrollPane1 = new javax.swing.JScrollPane();
    resultsTable = new javax.swing.JTable();
    resultsLabel = new javax.swing.JLabel();
    basicTabs = new MetadataTypesTable();

    setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    setTitle("Metadata Search Results");

    resultsTable.setModel(new javax.swing.table.DefaultTableModel(
      new Object [][] {
        {null, null},
        {null, null},
        {null, null},
        {null, null}
      },
      new String [] {
        "Cell Name", "Cell ID"
      }
    ) {
      Class[] types = new Class [] {
        java.lang.String.class, java.lang.String.class
      };
      boolean[] canEdit = new boolean [] {
        false, false
      };

      public Class getColumnClass(int columnIndex) {
        return types [columnIndex];
      }

      public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
      }
    });
    jScrollPane1.setViewportView(resultsTable);

    resultsLabel.setText("# Results");

    basicTabs.setPreferredSize(new java.awt.Dimension(32767, 32767));

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 147, Short.MAX_VALUE)
          .addComponent(resultsLabel))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(basicTabs, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(basicTabs, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 313, Short.MAX_VALUE)
          .addGroup(layout.createSequentialGroup()
            .addComponent(resultsLabel)
            .addGap(22, 22, 22)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)))
        .addContainerGap())
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  /**
   * a search was completed, set the results to display, fetch metadata
   * @param results maps cellID's to list of mid hits for that cell
   */
  void setResults(HashMap<CellID, MetadataCellInfo> results) {
    logger.info("[Search Results] set new results there are " + results.size());
    // clear out old values
    tabs.clearTabs();
    metaTablesCache.clear();
    searchResults.clear();
    resultsTable.setModel(new ResultsTableModel());


    // set results counter
    resultsLabel.setText(results.size() + " cells match search");
    searchResults = results;
    for(Entry<CellID, MetadataCellInfo> e : searchResults.entrySet()){
      CellID cid = e.getKey();
//      logger.info("[Search Results] cid: " + cid + ", num hits:" + e.getValue().size());
      ResultsTableModel mod = (ResultsTableModel) resultsTable.getModel();
      // get cell and cell id, get name, add row
      String cellName = null;
      mod.addRow(e.getKey(), e.getValue().getName());
    }
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JTabbedPane basicTabs;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JLabel resultsLabel;
  private javax.swing.JTable resultsTable;
  // End of variables declaration//GEN-END:variables

  // End of variables declaration

  class ResultsTableModel extends AbstractTableModel{
    ArrayList<CellID> cids = new ArrayList<CellID>();
    ArrayList<String> names = new ArrayList<String>();
    public int getRowCount() {
      return cids.size();
    }

    public int getColumnCount() {
      return 2;
    }

    public Object getValueAt(int rowIndex, int columnIndex) {
      switch (columnIndex){
        case 0:
          if(rowIndex < cids.size()){
            return cids.get(rowIndex);
          }
          return null;
        case 1:
          if(rowIndex < names.size()){
            return names.get(rowIndex);
          }
          break;
      }
      return null;
    }

    void addRow(CellID cid, String name){
      logger.info("add row in search model");
//      logger.info("before adding, model size:" + cids.size());
      cids.add(cid);
      names.add(name);
      int row = cids.size() - 1;
      this.fireTableRowsInserted(cids.size() - 1,
                                 cids.size() - 1);
//      logger.info("after adding, model size:" + cids.size());
    }

    /**
     * disallow all edits
     * @param row
     * @param col
     * @return
     */
    @Override
    public boolean isCellEditable(int row, int col) {
      // never editable
      return false;
    }

  }

  public void tableChanged(TableModelEvent e) {
    logger.info("[SEARCH RESULTS] res table changed, repaint");
    repaint();
  }

  /**
   * build a cell's MetadataTypesTable, using our stored information
   *
   * then cache it
   * 
   * @param cid
   */
  private void buildMTTForCell(CellID cid) {
    // this table could be connected to a cell, allowing edits and receiving updates
    // for now, this is effectively a static snapshot of the cell's metadata
    // from the time of the search
    logger.info("[SEARCH RESULTS] building MTT");
    MetadataTypesTable mtt = new MetadataTypesTable();
    mtt.setTableCellsEditable(MetadataTypesTable.AllowEdits.NEVER);
    MetadataCellInfo cellInfo = searchResults.get(cid);

    // load metadata, set which mids to highlight
    mtt.addMetadata(cellInfo.getMetadata(), cellInfo.getHits());
    metaTablesCache.put(cid, mtt);
  }

  /**
   * listens for selections of a row in the results panel
   * when a cell is selected, display its MetadataTypesTable
   */
  class resultsSelectionListener implements ListSelectionListener {
    public void valueChanged(ListSelectionEvent e) {
      boolean valid = false;
      int selectedIdx = resultsTable.getSelectedRow();
      if (!e.getValueIsAdjusting() && selectedIdx >= 0) {
          valid = true;
      }
      if(!valid){
        logger.info("[SEARCH RESULTS] invalid selection!");
        return;
      }
      CellID cid = (CellID) resultsTable.getValueAt(selectedIdx, 0);
      logger.info("[SEARCH RESULTS] selected new result: " + selectedIdx +
              " which is cid: " + cid);

      // if already in the cache, simply display that table
      if(!metaTablesCache.containsKey(cid)){
        logger.info("[SEARCH RESULTS] was not in cache, build");
        buildMTTForCell(cid);
      }
      tabs = metaTablesCache.get(cid);
      basicTabs = metaTablesCache.get(cid);
      tabs.repaint();
      basicTabs.repaint();
      MetadataSearchResultsForm.this.remove(basicTabs);
      MetadataSearchResultsForm.this.add(basicTabs);
      MetadataSearchResultsForm.this.repaint();
    }
  }
}
