/**
 * Copyright (c) 2014, WonderBuilders, Inc., All Rights Reserved
 */
package com.wonderbuilders.modules.attachto.client;

import com.jme.math.Vector3f;
import com.jme.scene.Node;
import com.jme.scene.Spatial;
import com.wonderbuilders.modules.attachto.common.AttachToComponentServerState;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Vector;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
import org.jdesktop.mtgame.RenderComponent;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.MovableComponent;
import org.jdesktop.wonderland.client.cell.properties.CellPropertiesEditor;
import org.jdesktop.wonderland.client.cell.properties.annotation.PropertiesFactory;
import org.jdesktop.wonderland.client.cell.properties.spi.PropertiesFactorySPI;
import org.jdesktop.wonderland.client.jme.cellrenderer.CellRendererJME;
import org.jdesktop.wonderland.common.cell.CellTransform;

/**
 * GUI panel for component configuration.
 *
 * @author Abhishek Upadhyay
 */
@PropertiesFactory(AttachToComponentServerState.class)
public class AttachToComponentProperties extends JPanel implements PropertiesFactorySPI {

    private CellPropertiesEditor editor;
    private List<Cell> cells;
    private List<Node> nodes;
    private String origCellName = "";
    private String origNodeName = "";
    private String currCellName = "";
    private String currNodeName = "";
    private Cell targetCell = null;

    public AttachToComponentProperties() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        cellCb = new javax.swing.JComboBox();
        nodeCb = new javax.swing.JComboBox();

        jLabel1.setFont(new java.awt.Font("Verdana", 1, 12)); // NOI18N
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("com/wonderbuilders/modules/attachto/client/resources/strings"); // NOI18N
        jLabel1.setText(bundle.getString("AttachToComponentProperties.jLabel1.text")); // NOI18N

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel2.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel2.setText(bundle.getString("AttachToComponentProperties.jLabel2.text")); // NOI18N

        jLabel3.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel3.setText(bundle.getString("AttachToComponentProperties.jLabel3.text")); // NOI18N

        cellCb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        cellCb.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cellCbActionPerformed(evt);
            }
        });

        nodeCb.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        nodeCb.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nodeCbActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(21, 21, 21)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(cellCb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(nodeCb, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cellCb, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(nodeCb))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void cellCbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cellCbActionPerformed
        // TODO add your handling code here:
        currCellName = ((Cell) cellCb.getSelectedItem()).getName();
        initializeNodes();
        checkDirty();
    }//GEN-LAST:event_cellCbActionPerformed

    private void nodeCbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nodeCbActionPerformed
        // TODO add your handling code here:
        currNodeName = ((Node) nodeCb.getSelectedItem()).getName();
        checkDirty();
    }//GEN-LAST:event_nodeCbActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox cellCb;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox nodeCb;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns human-readable name of the component.
     *
     * @return
     */
    @Override
    public String getDisplayName() {
        return "Attach-To";
    }

    @Override
    public void setCellPropertiesEditor(CellPropertiesEditor editor) {
        this.editor = editor;
    }

    @Override
    public JPanel getPropertiesJPanel() {
        return this;
    }

    @Override
    public void open() {
        initializeCells();
        initializeNodes();
        AttachToComponentServerState serverState = (AttachToComponentServerState) editor.getCellServerState()
                .getComponentServerState(AttachToComponentServerState.class);
        if (serverState != null) {
            origCellName = serverState.getCellName();
            origNodeName = serverState.getNodeName();
            currCellName = serverState.getCellName();
            currNodeName = serverState.getNodeName();
            this.targetCell = null;
            final Cell c = getTargetCell(currCellName,editor.getCell().getCellCache().getRootCells());
            if (c == null) {
                SwingUtilities.invokeLater(new Runnable() {

                    @Override
                    public void run() {
                        cellCb.setSelectedIndex(0);
                        nodeCb.setSelectedIndex(0);
                    }
                });
            } else {
                SwingUtilities.invokeLater(new Runnable() {

                    @Override
                    public void run() {
                        cellCb.setSelectedItem(c);
                        nodeCb.setSelectedItem(getTargetNode(c, currNodeName));
                    }
                });
                
            }
        }
        checkDirty();
    }

    @Override
    public void close() {
    }

    @Override
    public void restore() {
    }

    @Override
    public void apply() {
        AttachToComponentServerState serverState = (AttachToComponentServerState) editor.getCellServerState()
                .getComponentServerState(AttachToComponentServerState.class);
        if (serverState == null) {
            serverState = new AttachToComponentServerState();
        }
        serverState.setCellName(currCellName);
        serverState.setNodeName(currNodeName);
        editor.addToUpdateList(serverState);

        if (!currCellName.equals("") && !currNodeName.equals("")) {
            Node targetNode = (Node) nodeCb.getSelectedItem();
            MovableComponent mc = editor.getCell().getComponent(MovableComponent.class);
            CellTransform trans = editor.getCell().getLocalTransform();
            Vector3f pos = targetNode.getWorldTranslation();
            pos.setY((float) (pos.getY() - 0.01));
            trans.setTranslation(pos);
            mc.localMoveRequest(trans);
            AttachToComponent atc = editor.getCell().getComponent(AttachToComponent.class);
            System.out.println("attaching from properties...");
            atc.attachTransformChangeListener((Node) nodeCb.getSelectedItem());
        }

    }

    private void checkDirty() {
        boolean dirty = false;
        
        dirty |= !currCellName.equals(origCellName);
        dirty |= !currNodeName.equals(origNodeName);

        if (dirty) {
            editor.setPanelDirty(AttachToComponentProperties.class, dirty);
        } else {
            editor.setPanelDirty(AttachToComponentProperties.class, dirty);
        }
    }

    private void initializeCells(List<Cell> cells) {
        for (Cell cell : cells) {
            this.cells.add(cell);
            initializeCells(cell.getChildren());
        }
    }

    private void initializeCells() {
        cells = new ArrayList<Cell>();
        Cell emptyC = new Cell(null, null);
        emptyC.setName("");
        cells.add(emptyC);
        initializeCells((List<Cell>) editor.getCell().getCellCache().getRootCells());
        //sort the cells
        Collections.sort(cells,new Comparator<Cell>() {

            @Override
            public int compare(Cell o1, Cell o2) {
                return o1.getName().toLowerCase().compareTo(o2.getName().toLowerCase());
            }
        });
        cellCb.setModel(new DefaultComboBoxModel(new Vector(cells)));
        cellCb.setRenderer(new CellComboBoxRenderer());
    }

    private void initializeNodes(Node node) {
        List<Spatial> nodes = node.getChildren();
        if (nodes != null && !nodes.isEmpty()) {
            for (Spatial s : nodes) {
                if (s instanceof Node) {
                    Node n = (Node) s;
                    this.nodes.add(n);
                    initializeNodes(n);
                }
            }
        }
    }

    private void initializeNodes() {
        nodes = new ArrayList<Node>();
        Node emtyN = new Node("");
        nodes.add(emtyN);
        Cell selectedCell = (Cell) cellCb.getSelectedItem();
        CellRendererJME rend = (CellRendererJME) selectedCell.getCellRenderer(Cell.RendererType.RENDERER_JME);
        if (rend != null) {
            RenderComponent rc = rend.getEntity().getComponent(RenderComponent.class);
            if (rc != null) {
                initializeNodes(rc.getSceneRoot());
            }
        }
        //sort the nodes
        Collections.sort(nodes, new Comparator<Node>() {

            @Override
            public int compare(Node o1, Node o2) {
                if(o1!=null && o1.getName()!=null && o2!=null && o2.getName()!=null) {
                    return o1.getName().toLowerCase().compareTo(o2.getName().toLowerCase());
                } else {
                    return 1;
                }
            }
        });
        nodeCb.setModel(new DefaultComboBoxModel(new Vector(nodes)));
        nodeCb.setRenderer(new NodeComboBoxRenderer());
    }

    class CellComboBoxRenderer extends BasicComboBoxRenderer {

        @Override
        public Component getListCellRendererComponent(
                JList list,
                Object value,
                int index,
                boolean isSelected,
                boolean cellHasFocus) {
            super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
            Cell cell = (Cell) value;
            setText(cell.getName());
            return this;
        }
    }

    class NodeComboBoxRenderer extends BasicComboBoxRenderer {

        @Override
        public Component getListCellRendererComponent(
                JList list,
                Object value,
                int index,
                boolean isSelected,
                boolean cellHasFocus) {
            super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
            Node node = (Node) value;
            if (node != null) {
                setText(node.getName());
            }
            return this;
        }
    }

    private Node getTargetNode(Cell cell, String name) {
        CellRendererJME rend = (CellRendererJME) cell.getCellRenderer(Cell.RendererType.RENDERER_JME);
        RenderComponent rc = rend.getEntity().getComponent(RenderComponent.class);
        return (Node) rc.getSceneRoot().getChild(name);
    }

    private Cell getTargetCell(String name, Collection<Cell> cells) {
        for (Cell cell : cells) {
            if (cell.getName().equals(name)) {
                targetCell = cell;
                return targetCell;
            } else {
                getTargetCell(name, cell.getChildren());
            }
        }
        return targetCell;
    }
}
